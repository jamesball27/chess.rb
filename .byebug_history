c
n
two_step
n
one_step
n
color
forward_dir
y
x
c
moves
c
new_board.in_check?(color)
new_board
n
c
new_board.grid
new_board
n
new_board
n
end_pos
c
n
move
moves.reject! { |move| move_into_check?(move) }
moves
c
n
moves
c
row
pos
n
s
row
s
new_board.grid
new_board
exit
c
side_attacks
forward_steps
c
disp piece
c
disp piece
exit
c
pos
c
disp piece
c
board.in_bounds?(pos)
board.in_bounds?
board
pos
forward_steps
c
disp piece
exit
forward_steps
c
disp piece
c
disp piece
piece
c
piece.moves.include?(king)
king
piece.moves
piece
exit
opponent_pieces
piece
grid.flatten.length
grid.flatten
grid
piece.moves
piece
n
opponent_pieces.all? {|p| p.color == opponent_color }
opponent_pieces.count
opponent_pieces
n
opponent_color
n
king
n
color
exit
c
pos
exit
c
moves
c
board[new_pos]
board.in_bounds?(new_pos)
board
moves.last
pos
new_pos
move_deltas
dy
dx
n
s
move_deltas
c
grid[i]
disp i
disp
s
c
n
grid
n
grid
